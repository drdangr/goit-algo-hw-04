# goit-algo-hw-04

# Порівняння алгоритмів сортування: insertion sort, merge sort та Timsort

## 1. Постановка задачі

Мета роботи — на практиці порівняти три алгоритми сортування:

- insertion sort (сортування вставками),
- merge sort (сортування злиттям),
- Timsort (вбудований `sorted` у Python),

Також треба перевірити, чи відповідає їхня реальна швидкість теоретичній складності.  
Окрема ціль — показати, чому гібридний алгоритм Timsort виявляється значно ефективнішим у реальних умовах.


## 2. Метод дослідження

Що зроблено:

1. Реалізувано алгоритми **insertion sort** та **merge sort** вручну.
2. Використано вбудований `sorted()` як представника Timsort.
3. Для вимірювання часу використано модуль `timeit`.

Алгоритми тестувалися на масивах цілих чисел розміром:

- `1000`, `5000`, `10000`, `20000` елементів.

Для кожного розміру генерувалися 4 типи вхідних даних:

- `random` — випадкові числа,
- `sorted` — вже відсортований список,
- `reversed` — список у зворотному порядку,
- `almost_sorted` — майже відсортований список з декількома випадковими перестановками.

Кожен вимір виконувався 3 рази, 
у таблиці нижче наведено сумарний час для `n = 20000` як найбільш показового випадку.

---

## 3. Результати (n = 20000)

| Тип даних     | insertion_sort, c | merge_sort, c | timsort (`sorted`), c |
| ------------- | ----------------- | ------------- | --------------------- |
| random        | 8.9417            | 0.0578        | 0.0039                |
| sorted        | 0.0025            | 0.0371        | 0.0003                |
| reversed      | 17.8747           | 0.0408        | 0.0003                |
| almost_sorted | 0.0145            | 0.0408        | 0.0003                |

Загальна картина для менших розмірів (1000, 5000, 10000) така ж, 
тільки з меншими абсолютними значеннями часу.

---

## 4. Висновки: очікування vs результат

### Теоретично** очікувалося:

- Insertion sort
  - `O(n)` у найкращому випадку (вже відсортований список),
  - `O(n²)` у середньому та гіршому випадках.
- Merge sort
  - стабільна складність `O(n log n)` незалежно від порядку елементів.
- Timsort
  - `O(n log n)` у гіршому випадку,
  - але завдяки поєднанню ідей insertion sort і merge sort та виявленню
    вже відсортованих підпослідовностей повинен бути дуже швидким на реальних даних.

### Фактично** вимірювання це підтвердили:

- Insertion sort
    - Для випадкових та зворотних масивів час росте приблизно як `n²`:  
  для `random` від `1000` до `20000` елементів час збільшився з ~`0.0225 c` до ~`8.94 c`.  
  На `reversed` для `20000` елементів алгоритм взагалі показав ~`17.87 c`.
- Merge sort
    - значно швидший, час росте набагато м’якіше, близько до `n log n`.  
    - майже не реагує на те, відсортовані дані чи ні.
- Timsort (`sorted`) 
    - виявився найшвидшим у всіх сценаріях:
    - на `random, n = 20000` він приблизно у 10–15 разів швидший
      за merge sort і на порядки швидший за insertion sort;
    - на `sorted` та `almost_sorted` він показує мінімальний час, 
      виграючи як у merge sort, так і в insertion sort.

## 5. Підсумок. 
Емпіричні результати добре збігаються з теоретичними очікуваннями та демонструють, що:

- insertion sort ефективний лише для дуже малих або майже відсортованих масивів;
- merge sort стабільно швидкий, але не враховує особливості вхідних даних;
- гібридний підхід Timsort, який поєднує ідеї сортування злиттям та вставками і оптимізований 
  під реальні дані, дає найкращу продуктивність;

Тому: 
у реальних проєктах доцільно використовувати вбудовані засоби Python (`sorted`, `list.sort`).